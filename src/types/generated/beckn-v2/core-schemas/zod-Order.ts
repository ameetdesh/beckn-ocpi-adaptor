import { z } from "zod";

export default z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Order"), "beckn:id": z.string(), "beckn:orderStatus": z.string().describe("Order status/state"), "beckn:orderNumber": z.string().describe("Human-visible order number").optional(), "beckn:seller": z.string().describe("Unique identifier for the provider"), "beckn:buyer": z.string().describe("Unique identifier for the buyer (personId or orgId in legacy schema)"), "beckn:orderItems": z.array(z.object({ "beckn:lineId": z.string().describe("Unique line id within order"), "beckn:orderedItem": z.string().describe("Unique identifier for the item"), "beckn:acceptedOffer": z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Offer"), "beckn:id": z.string().describe("Unique id for this offer"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:provider": z.string().describe("Seller / provider of this offer"), "beckn:items": z.array(z.string().describe("Unique identifier for the item")).min(1).describe("Base item(s) the offer applies to (single or bundle)"), "beckn:addOns": z.array(z.string().describe("Unique id for this offer")).describe("Optional extra Offers that can be attached (e.g., warranty, gift wrap)").optional(), "beckn:addOnItems": z.array(z.string().describe("Unique identifier for the item")).describe("Optional extras modeled as items (e.g., toppings, accessories)").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:price": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Price snapshot; detailed models can live in offerAttributes").optional(), "beckn:eligibleRegion": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Regions where the offer is eligible").optional(), "beckn:acceptedPaymentMethod": z.array(z.enum(["UPI","CreditCard","DebitCard","Wallet","BankTransfer","Cash","ApplePay"])).describe("Payment methods accepted for this offer").optional(), "beckn:itemCondition": z.enum(["NEW","USED","REFURBISHED","DAMAGED"]).describe("Condition of the item being offered").optional(), "beckn:offerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict().describe("Offer applied to this line (if different from order-level)").optional(), "beckn:quantity": z.number(), "beckn:price": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Line price composition (unit/tax/delivery/discount)").optional(), "beckn:orderItemAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() })).min(1), "beckn:acceptedOffers": z.array(z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Offer"), "beckn:id": z.string().describe("Unique id for this offer"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:provider": z.string().describe("Seller / provider of this offer"), "beckn:items": z.array(z.string().describe("Unique identifier for the item")).min(1).describe("Base item(s) the offer applies to (single or bundle)"), "beckn:addOns": z.array(z.string().describe("Unique id for this offer")).describe("Optional extra Offers that can be attached (e.g., warranty, gift wrap)").optional(), "beckn:addOnItems": z.array(z.string().describe("Unique identifier for the item")).describe("Optional extras modeled as items (e.g., toppings, accessories)").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:price": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Price snapshot; detailed models can live in offerAttributes").optional(), "beckn:eligibleRegion": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Regions where the offer is eligible").optional(), "beckn:acceptedPaymentMethod": z.array(z.enum(["UPI","CreditCard","DebitCard","Wallet","BankTransfer","Cash","ApplePay"])).describe("Payment methods accepted for this offer").optional(), "beckn:itemCondition": z.enum(["NEW","USED","REFURBISHED","DAMAGED"]).describe("Condition of the item being offered").optional(), "beckn:offerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict()).describe("Offers accepted at order-level (optional if captured per line)").optional(), "beckn:orderValue": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Order totals snapshot (derivable from lines; optional)").optional(), "beckn:invoice": z.string().describe("Invoice reference/summary").optional(), "beckn:payment": z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Payment"), "beckn:id": z.string().describe("Payment record identifier"), "beckn:status": z.string().describe("Payment lifecycle status (Pending | Authorized | Captured | Failed | Refunded | PartialRefund …)"), "beckn:amount": z.object({ "currency": z.string().optional(), "value": z.number().optional() }).describe("Amount associated with this payment action").optional(), "beckn:paymentURL": z.string().url().describe("URL for payment processing/redirection").optional(), "beckn:txnRef": z.string().describe("PSP/gateway/bank transaction reference").optional(), "beckn:paidAt": z.string().datetime({ offset: true }).nullable().describe("When the last terminal event (capture/refund) happened").optional(), "beckn:acceptedPaymentMethod": z.array(z.enum(["UPI","CreditCard","DebitCard","Wallet","BankTransfer","Cash","ApplePay"])).describe("Payment methods accepted for this offer").optional(), "beckn:beneficiary": z.string().describe("Who will be the beneficiary or recipient of the payment").optional(), "beckn:paymentAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict().describe("Method/status; rail-specific payloads go to packs").optional(), "beckn:fulfillment": z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Fulfillment"), "beckn:id": z.string().describe("Fulfillment identifier"), "beckn:status": z.enum(["PENDING","CONFIRMED","COMPLETED","CANCELLED","QUOTED"]).describe("Network-defined status code (e.g., OutForDelivery, ReadyForPickup, Confirmed)").optional(), "beckn:mode": z.enum(["DELIVERY","PICKUP","RESERVATION","DIGITAL"]).describe("DELIVERY    → last-mile / parcel logistics\nPICKUP      → customer collects from a place\nRESERVATION → entitlement/booking is fulfilled (tickets, seats, appointments)\nDIGITAL     → digital good / license access\n"), "trackingAction": z.object({ "target": z.object({ "url": z.string().url().describe("Tracking page URL").optional() }).catchall(z.any()).describe("schema.org EntryPoint").optional(), "deliveryMethod": z.enum(["DELIVERY","PICKUP","RESERVATION","DIGITAL"]).describe("DELIVERY    → last-mile / parcel logistics\nPICKUP      → customer collects from a place\nRESERVATION → entitlement/booking is fulfilled (tickets, seats, appointments)\nDIGITAL     → digital good / license access\n").optional(), "reservationId": z.string().describe("Unique identifier for the reservation (schema.org Reservation.reservationId).").optional() }).catchall(z.any()).describe("Tracking entrypoint for this fulfillment, modeled as schema.org TrackAction. Use target.url for a clickable tracking URL; may also include deliveryMethod.\n").optional(), "beckn:deliveryAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict().describe("Parcel delivery or reservation summary").optional(), "beckn:orderAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict();
