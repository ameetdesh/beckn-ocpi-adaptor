import { z } from "zod";

export default z.object({ "breakup": z.array(z.object({ "item": z.object({ "add_ons": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "id": z.string().describe("ID of the add-on. This follows the syntax {item.id}/add-on/{add-on unique id} for item specific add-on OR ").optional(), "price": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").optional() }).strict().describe("Describes an add-on")).optional(), "cancellation_terms": z.array(z.object({ "cancel_by": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Information related to the time of cancellation.").optional(), "cancellation_fee": z.object({ "amount": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").describe("A fixed value").optional(), "percentage": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").describe("Percentage of a value").optional() }).strict().describe("A fee applied on a particular entity"), "external_ref": z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.").optional(), "fulfillment_state": z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "updated_at": z.string().datetime({ offset: true }).optional(), "updated_by": z.string().describe("ID of entity which changed the state").optional() }).strict().describe("Describes the state of fulfillment").describe("The state of fulfillment during which this term is applicable.").optional(), "reason_required": z.boolean().describe("Indicates whether a reason is required to cancel the order").optional(), "xinput": z.object({ "form": z.object({ "data": z.record(z.string()).describe("The form submission data").optional(), "mime_type": z.enum(["text/html","application/xml"]).describe("This field indicates the nature and format of the form received by querying the url. MIME types are defined and standardized in IETF's RFC 6838.").optional(), "submission_id": z.string().uuid().optional(), "url": z.string().url().describe("The URL from where the form can be fetched. The content fetched from the url must be processed as per the mime_type specified in this object. Once fetched, the rendering platform can choosed to render the form as-is as an embeddable element; or process it further to blend with the theme of the application. In case the interface is non-visual, the the render can process the form data and reproduce it as per the standard specified in the form.").optional() }).strict().describe("Describes a form").optional(), "required": z.boolean().describe("Indicates whether the form data is mandatorily required by the BPP to confirm the order.").optional() }).strict().describe("Contains any additional or extended inputs required to confirm an order. This is typically a Form Input. Sometimes, selection of catalog elements is not enough for the BPP to confirm an order. For example, to confirm a flight ticket, the airline requires details of the passengers along with information on baggage, identity, in addition to the class of ticket. Similarly, a logistics company may require details on the nature of shipment in order to confirm the shipping. A recruiting firm may require additional details on the applicant in order to confirm a job application. For all such purposes, the BPP can choose to send this object attached to any object in the catalog that is required to be sent while placing the order. This object can typically be sent at an item level or at the order level. The item level XInput will override the Order level XInput as it indicates a special requirement of information for that particular item. Hence the BAP must render a separate form for the Item and another form at the Order level before confirmation.").optional() }).strict().describe("Describes the cancellation terms of an item or an order. This can be referenced at an item or order level. Item-level cancellation terms can override the terms at the order level.")).describe("Cancellation terms of this item").optional(), "category_ids": z.array(z.string().describe("ID of the category")).describe("Categories this item can be listed under").optional(), "creator": z.object({ "address": z.string().describe("Describes a postal address.").describe("The postal address of the organization").optional(), "city": z.object({ "code": z.string().describe("City code").optional(), "name": z.string().describe("Name of the city").optional() }).strict().describe("Describes a city").describe("The city where the the organization's address is registered").optional(), "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().optional(), "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state where the organization's address is registered").optional() }).strict().describe("An organization. Usually a recognized business entity.").describe("The creator of this item").optional(), "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Physical description of the item").optional(), "fulfillment_ids": z.array(z.string().describe("Unique reference ID to the fulfillment of an order")).describe("Modes through which this item can be fulfilled").optional(), "id": z.string().describe("ID of the item.").optional(), "location_ids": z.array(z.string()).describe("Provider Locations this item is available in").optional(), "matched": z.boolean().describe("Whether this item is an exact match of the request").optional(), "parent_item_id": z.string().describe("ID of the item.").describe("ID of the item, this item is a variant of").optional(), "parent_item_quantity": z.object({ "allocated": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the exact quantity allocated for purchase of the item.").optional(), "available": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the exact quantity available for purchase of the item. The buyer can only purchase multiples of this").optional(), "maximum": z.object({ "count": z.number().int().gte(1).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the maximum quantity allowed for purchase of the item").optional(), "minimum": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the minimum quantity allowed for purchase of the item").optional(), "selected": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the quantity selected for purchase of the item").optional(), "unitized": z.object({ "count": z.number().int().gte(1).lte(1).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the quantity available in a single unit of the item").optional() }).strict().describe("Describes the count or amount of an item").describe("The number of units of the parent item this item is a multiple of").optional(), "payment_ids": z.array(z.string().describe("ID of the payment term that can be referred at an item or an order level in a catalog")).describe("Payment modalities through which this item can be ordered").optional(), "price": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").describe("The price of this item, if it has intrinsic value").optional(), "quantity": z.object({ "allocated": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the exact quantity allocated for purchase of the item.").optional(), "available": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the exact quantity available for purchase of the item. The buyer can only purchase multiples of this").optional(), "maximum": z.object({ "count": z.number().int().gte(1).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the maximum quantity allowed for purchase of the item").optional(), "minimum": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the minimum quantity allowed for purchase of the item").optional(), "selected": z.object({ "count": z.number().int().gte(0).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the quantity selected for purchase of the item").optional(), "unitized": z.object({ "count": z.number().int().gte(1).lte(1).optional(), "measure": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).describe("This represents the quantity available in a single unit of the item").optional() }).strict().describe("Describes the count or amount of an item").describe("The selling quantity of the item").optional(), "rateable": z.boolean().describe("Whether this item can be rated").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").describe("The rating of the item").optional(), "recommended": z.boolean().describe("Whether this item is a recommended item to a response").optional(), "refund_terms": z.array(z.object({ "fulfillment_state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state of fulfillment during which this term is applicable.").optional(), "refund_amount": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").optional(), "refund_eligible": z.boolean().describe("Indicates if cancellation will result in a refund").optional(), "refund_within": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Time within which refund will be processed after successful cancellation.").optional() }).describe("Refund term of an item or an order")).describe("Refund terms of this item").optional(), "related": z.boolean().describe("Whether this item is a related item to the exactly matched item").optional(), "replacement_terms": z.array(z.object({ "external_ref": z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.").optional(), "fulfillment_state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state of fulfillment during which this term is applicable.").optional(), "replace_within": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Applicable only for buyer managed returns where the buyer has to replace the item before a certain date-time, failing which they will not be eligible for replacement").optional() }).strict().describe("The replacement policy of an item or an order")).describe("Terms that are applicable be met when this item is replaced").optional(), "return_terms": z.array(z.object({ "fulfillment_managed_by": z.string().describe("The entity that will perform the return").optional(), "fulfillment_state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state of fulfillment during which this term IETF''s applicable.").optional(), "return_eligible": z.boolean().describe("Indicates whether the item is eligible for return").optional(), "return_location": z.object({ "3dspace": z.string().describe("The three dimensional region describing this location").optional(), "address": z.string().describe("Describes a postal address.").describe("The address of this location.").optional(), "area_code": z.string().optional(), "circle": z.object({ "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d{6,})?|90(\\.0{6,})?),\\s*[-+]?(180(\\.0{6,})?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d{6,})?)$")).describe("Describes a gps coordinate").optional(), "radius": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).strict().describe("Describes a circular region of a specified radius centered at a specified GPS coordinate.").optional(), "city": z.object({ "code": z.string().describe("City code").optional(), "name": z.string().describe("Name of the city").optional() }).strict().describe("Describes a city").describe("The city this location is, or is located within").optional(), "country": z.object({ "code": z.string().describe("Country code as per ISO 3166-1 and ISO 3166-2 format").optional(), "name": z.string().describe("Name of the country").optional() }).strict().describe("Describes a country.").describe("The country this location is, or is located within").optional(), "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "district": z.string().describe("The state this location is, or is located within").optional(), "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d{6,})?|90(\\.0{6,})?),\\s*[-+]?(180(\\.0{6,})?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d{6,})?)$")).describe("Describes a gps coordinate").describe("The GPS co-ordinates of this location.").optional(), "id": z.string().optional(), "map_url": z.string().url().describe("The url to the map of the location. This can be a globally recognized map url or the one specified by the network policy.").optional(), "polygon": z.string().describe("The boundary polygon of this location").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").describe("The rating of this location").optional(), "state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state this location is, or is located within").optional() }).strict().describe("The physical location of something").describe("The location where the item or order must / will be returned to").optional(), "return_time": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Applicable only for buyer managed returns where the buyer has to return the item to the origin before a certain date-time, failing which they will not be eligible for refund.").optional() }).strict().describe("Describes the return policy of an item or an order")).describe("Terms that are applicable when this item is returned").optional(), "tags": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the TagGroup, can be used to store detailed information.").optional(), "display": z.boolean().describe("Indicates the display properties of the tag group. If display is set to false, then the group will not be displayed. If it is set to true, it should be displayed. However, group-level display properties can be overriden by individual tag-level display property. As this schema is purely for catalog display purposes, it is not recommended to send this value during search.").default(true), "list": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the Tag, can be used to store detailed information.").optional(), "display": z.boolean().describe("This value indicates if the tag is intended for display purposes. If set to `true`, then this tag must be displayed. If it is set to `false`, it should not be displayed. This value can override the group display value.").optional(), "value": z.string().describe("The value of the tag. This set by the BPP and rendered as-is by the BAP.").optional() }).strict().describe("Describes a tag. This is used to contain extended metadata. This object can be added as a property to any schema to describe extended attributes. For BAPs, tags can be sent during search to optimize and filter search results. BPPs can use tags to index their catalog to allow better search functionality. Tags are sent by the BPP as part of the catalog response in the `on_search` callback. Tags are also meant for display purposes. Upon receiving a tag, BAPs are meant to render them as name-value pairs. This is particularly useful when rendering tabular information about a product or service.")).describe("An array of Tag objects listed under this group. This property can be set by BAPs during search to narrow the `search` and achieve more relevant results. When received during `on_search`, BAPs must render this list under the heading described by the `name` property of this schema.").optional() }).strict().describe("A collection of tag objects with group level attributes. For detailed documentation on the Tags and Tag Groups schema go to https://github.com/beckn/protocol-specifications/discussions/316")).optional(), "time": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Temporal attributes of this item. This property is used when the item exists on the catalog only for a limited period of time.").optional(), "ttl": z.string().describe("Time to live in seconds for an instance of this schema").optional(), "xinput": z.object({ "form": z.object({ "data": z.record(z.string()).describe("The form submission data").optional(), "mime_type": z.enum(["text/html","application/xml"]).describe("This field indicates the nature and format of the form received by querying the url. MIME types are defined and standardized in IETF's RFC 6838.").optional(), "submission_id": z.string().uuid().optional(), "url": z.string().url().describe("The URL from where the form can be fetched. The content fetched from the url must be processed as per the mime_type specified in this object. Once fetched, the rendering platform can choosed to render the form as-is as an embeddable element; or process it further to blend with the theme of the application. In case the interface is non-visual, the the render can process the form data and reproduce it as per the standard specified in the form.").optional() }).strict().describe("Describes a form").optional(), "required": z.boolean().describe("Indicates whether the form data is mandatorily required by the BPP to confirm the order.").optional() }).strict().describe("Contains any additional or extended inputs required to confirm an order. This is typically a Form Input. Sometimes, selection of catalog elements is not enough for the BPP to confirm an order. For example, to confirm a flight ticket, the airline requires details of the passengers along with information on baggage, identity, in addition to the class of ticket. Similarly, a logistics company may require details on the nature of shipment in order to confirm the shipping. A recruiting firm may require additional details on the applicant in order to confirm a job application. For all such purposes, the BPP can choose to send this object attached to any object in the catalog that is required to be sent while placing the order. This object can typically be sent at an item level or at the order level. The item level XInput will override the Order level XInput as it indicates a special requirement of information for that particular item. Hence the BAP must render a separate form for the Item and another form at the Order level before confirmation.").describe("Additional input required from the customer to purchase / avail this item").optional() }).strict().describe("Describes a product or a service offered to the end consumer by the provider. In the mobility sector, it can represent a fare product like one way journey. In the logistics sector, it can represent the delivery service offering. In the retail domain it can represent a product like a grocery item.").optional(), "price": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").optional(), "title": z.string().optional() })).describe("the breakup of the total quoted price").optional(), "id": z.string().uuid().describe("ID of the quote.").optional(), "price": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "currency": z.string().optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "listed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "maximum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "minimum_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "offered_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes the price of an item. Allows for domain extension.").describe("The total quoted price").optional(), "ttl": z.string().describe("Describes duration as per ISO8601 format").optional() }).strict().describe("Describes a quote. It is the estimated price of products or services from the BPP.<br>This has properties like price, breakup, ttl");
