import { z } from "zod";

export default z.object({ "agent": z.object({ "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().optional(), "organization": z.object({ "address": z.string().describe("Describes a postal address.").describe("The postal address of the organization").optional(), "city": z.object({ "code": z.string().describe("City code").optional(), "name": z.string().describe("Name of the city").optional() }).strict().describe("Describes a city").describe("The city where the the organization's address is registered").optional(), "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().optional(), "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state where the organization's address is registered").optional() }).strict().describe("An organization. Usually a recognized business entity.").optional(), "person": z.object({ "age": z.string().describe("Describes duration as per ISO8601 format").describe("Age of the person").optional(), "creds": z.array(z.object({ "id": z.string().optional(), "type": z.string().default("VerifiableCredential"), "url": z.string().url().describe("URL of the credential").optional() }).strict().describe("Describes a credential of an entity - Person or Organization")).optional(), "dob": z.string().date().describe("Date of birth of the person").optional(), "gender": z.string().describe("Gender of something, typically a Person, but possibly also fictional characters, animals, etc. While Male and Female may be used, text strings are also acceptable for people who do not identify as a binary gender.Allowed values for this field can be published in the network policy").optional(), "id": z.string().describe("Describes the identity of the person").optional(), "image": z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image").optional(), "languages": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a language known to the person.")).optional(), "name": z.string().describe("the name of the person").optional(), "skills": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a skill of the person.")).optional(), "tags": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the TagGroup, can be used to store detailed information.").optional(), "display": z.boolean().describe("Indicates the display properties of the tag group. If display is set to false, then the group will not be displayed. If it is set to true, it should be displayed. However, group-level display properties can be overriden by individual tag-level display property. As this schema is purely for catalog display purposes, it is not recommended to send this value during search.").default(true), "list": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the Tag, can be used to store detailed information.").optional(), "display": z.boolean().describe("This value indicates if the tag is intended for display purposes. If set to `true`, then this tag must be displayed. If it is set to `false`, it should not be displayed. This value can override the group display value.").optional(), "value": z.string().describe("The value of the tag. This set by the BPP and rendered as-is by the BAP.").optional() }).strict().describe("Describes a tag. This is used to contain extended metadata. This object can be added as a property to any schema to describe extended attributes. For BAPs, tags can be sent during search to optimize and filter search results. BPPs can use tags to index their catalog to allow better search functionality. Tags are sent by the BPP as part of the catalog response in the `on_search` callback. Tags are also meant for display purposes. Upon receiving a tag, BAPs are meant to render them as name-value pairs. This is particularly useful when rendering tabular information about a product or service.")).describe("An array of Tag objects listed under this group. This property can be set by BAPs during search to narrow the `search` and achieve more relevant results. When received during `on_search`, BAPs must render this list under the heading described by the `name` property of this schema.").optional() }).strict().describe("A collection of tag objects with group level attributes. For detailed documentation on the Tags and Tag Groups schema go to https://github.com/beckn/protocol-specifications/discussions/316")).optional(), "url": z.string().url().describe("Profile url of the person").optional() }).strict().describe("Describes a person as any individual").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").optional() }).strict().describe("Describes the direct performer, driver or executor that fulfills an order. It is usually a person. But in some rare cases, it could be a non-living entity like a drone, or a bot. Some examples of agents are Doctor in the healthcare sector, a driver in the mobility sector, or a delivery person in the logistics sector. This object can be set at any stage of the order lifecycle. This can be set at the discovery stage when the BPP wants to provide details on the agent fulfilling the order, like in healthcare, where the doctor's name appears during search. This object can also used to search for a particular person that the customer wants fulfilling an order. Sometimes, this object gets instantiated after the order is confirmed, like in the case of on-demand taxis, where the driver is assigned after the user confirms the ride.").describe("The agent that is currently handling the fulfillment of the order").optional(), "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().optional(), "customer": z.object({ "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().optional(), "person": z.object({ "age": z.string().describe("Describes duration as per ISO8601 format").describe("Age of the person").optional(), "creds": z.array(z.object({ "id": z.string().optional(), "type": z.string().default("VerifiableCredential"), "url": z.string().url().describe("URL of the credential").optional() }).strict().describe("Describes a credential of an entity - Person or Organization")).optional(), "dob": z.string().date().describe("Date of birth of the person").optional(), "gender": z.string().describe("Gender of something, typically a Person, but possibly also fictional characters, animals, etc. While Male and Female may be used, text strings are also acceptable for people who do not identify as a binary gender.Allowed values for this field can be published in the network policy").optional(), "id": z.string().describe("Describes the identity of the person").optional(), "image": z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image").optional(), "languages": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a language known to the person.")).optional(), "name": z.string().describe("the name of the person").optional(), "skills": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a skill of the person.")).optional(), "tags": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the TagGroup, can be used to store detailed information.").optional(), "display": z.boolean().describe("Indicates the display properties of the tag group. If display is set to false, then the group will not be displayed. If it is set to true, it should be displayed. However, group-level display properties can be overriden by individual tag-level display property. As this schema is purely for catalog display purposes, it is not recommended to send this value during search.").default(true), "list": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the Tag, can be used to store detailed information.").optional(), "display": z.boolean().describe("This value indicates if the tag is intended for display purposes. If set to `true`, then this tag must be displayed. If it is set to `false`, it should not be displayed. This value can override the group display value.").optional(), "value": z.string().describe("The value of the tag. This set by the BPP and rendered as-is by the BAP.").optional() }).strict().describe("Describes a tag. This is used to contain extended metadata. This object can be added as a property to any schema to describe extended attributes. For BAPs, tags can be sent during search to optimize and filter search results. BPPs can use tags to index their catalog to allow better search functionality. Tags are sent by the BPP as part of the catalog response in the `on_search` callback. Tags are also meant for display purposes. Upon receiving a tag, BAPs are meant to render them as name-value pairs. This is particularly useful when rendering tabular information about a product or service.")).describe("An array of Tag objects listed under this group. This property can be set by BAPs during search to narrow the `search` and achieve more relevant results. When received during `on_search`, BAPs must render this list under the heading described by the `name` property of this schema.").optional() }).strict().describe("A collection of tag objects with group level attributes. For detailed documentation on the Tags and Tag Groups schema go to https://github.com/beckn/protocol-specifications/discussions/316")).optional(), "url": z.string().url().describe("Profile url of the person").optional() }).strict().describe("Describes a person as any individual").optional() }).strict().describe("Describes a customer buying/availing a product or a service").describe("The person that will ultimately receive the order").optional(), "id": z.string().describe("Unique reference ID to the fulfillment of an order").optional(), "path": z.string().describe("The physical path taken by the agent that can be rendered on a map. The allowed format of this property can be set by the network.").optional(), "rateable": z.boolean().describe("Whether the fulfillment can be rated or not").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").describe("The rating value of the fulfullment service.").optional(), "state": z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "updated_at": z.string().datetime({ offset: true }).optional(), "updated_by": z.string().describe("ID of entity which changed the state").optional() }).strict().describe("Describes the state of fulfillment").describe("The current state of fulfillment. The BPP must set this value whenever the state of the order fulfillment changes and fire an unsolicited `on_status` call.").optional(), "stops": z.array(z.object({ "authorization": z.object({ "status": z.string().describe("Status of the token").optional(), "token": z.string().describe("Token used for authorization").optional(), "type": z.string().describe("Type of authorization mechanism used").optional(), "valid_from": z.string().datetime({ offset: true }).describe("Timestamp in RFC3339 format from which token is valid").optional(), "valid_to": z.string().datetime({ offset: true }).describe("Timestamp in RFC3339 format until which token is valid").optional() }).strict().describe("Describes an authorization mechanism").optional(), "contact": z.object({ "email": z.string().optional(), "jcard": z.record(z.any()).describe("A Jcard object as per draft-ietf-jcardcal-jcard-03 specification").optional(), "phone": z.string().optional() }).strict().describe("Contact details of the stop").optional(), "id": z.string().optional(), "instructions": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Instructions that need to be followed at the stop").optional(), "location": z.object({ "3dspace": z.string().describe("The three dimensional region describing this location").optional(), "address": z.string().describe("Describes a postal address.").describe("The address of this location.").optional(), "area_code": z.string().optional(), "circle": z.object({ "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d{6,})?|90(\\.0{6,})?),\\s*[-+]?(180(\\.0{6,})?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d{6,})?)$")).describe("Describes a gps coordinate").optional(), "radius": z.object({ "computed_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "estimated_value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "range": z.object({ "max": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional(), "min": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).optional(), "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "unit": z.string().optional(), "value": z.string().regex(new RegExp("^[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a decimal value").optional() }).strict().describe("Describes a scalar").optional() }).strict().describe("Describes a circular region of a specified radius centered at a specified GPS coordinate.").optional(), "city": z.object({ "code": z.string().describe("City code").optional(), "name": z.string().describe("Name of the city").optional() }).strict().describe("Describes a city").describe("The city this location is, or is located within").optional(), "country": z.object({ "code": z.string().describe("Country code as per ISO 3166-1 and ISO 3166-2 format").optional(), "name": z.string().describe("Name of the country").optional() }).strict().describe("Describes a country.").describe("The country this location is, or is located within").optional(), "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").optional(), "district": z.string().describe("The state this location is, or is located within").optional(), "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d{6,})?|90(\\.0{6,})?),\\s*[-+]?(180(\\.0{6,})?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d{6,})?)$")).describe("Describes a gps coordinate").describe("The GPS co-ordinates of this location.").optional(), "id": z.string().optional(), "map_url": z.string().url().describe("The url to the map of the location. This can be a globally recognized map url or the one specified by the network policy.").optional(), "polygon": z.string().describe("The boundary polygon of this location").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").describe("The rating of this location").optional(), "state": z.object({ "code": z.string().describe("State code as per country or international standards").optional(), "name": z.string().describe("Name of the state").optional() }).strict().describe("A bounded geopolitical region of governance inside a country.").describe("The state this location is, or is located within").optional() }).strict().describe("The physical location of something").describe("Location of the stop").optional(), "parent_stop_id": z.string().optional(), "person": z.object({ "age": z.string().describe("Describes duration as per ISO8601 format").describe("Age of the person").optional(), "creds": z.array(z.object({ "id": z.string().optional(), "type": z.string().default("VerifiableCredential"), "url": z.string().url().describe("URL of the credential").optional() }).strict().describe("Describes a credential of an entity - Person or Organization")).optional(), "dob": z.string().date().describe("Date of birth of the person").optional(), "gender": z.string().describe("Gender of something, typically a Person, but possibly also fictional characters, animals, etc. While Male and Female may be used, text strings are also acceptable for people who do not identify as a binary gender.Allowed values for this field can be published in the network policy").optional(), "id": z.string().describe("Describes the identity of the person").optional(), "image": z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image").optional(), "languages": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a language known to the person.")).optional(), "name": z.string().describe("the name of the person").optional(), "skills": z.array(z.object({ "code": z.string().optional(), "name": z.string().optional() }).describe("Describes a skill of the person.")).optional(), "tags": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the TagGroup, can be used to store detailed information.").optional(), "display": z.boolean().describe("Indicates the display properties of the tag group. If display is set to false, then the group will not be displayed. If it is set to true, it should be displayed. However, group-level display properties can be overriden by individual tag-level display property. As this schema is purely for catalog display purposes, it is not recommended to send this value during search.").default(true), "list": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the Tag, can be used to store detailed information.").optional(), "display": z.boolean().describe("This value indicates if the tag is intended for display purposes. If set to `true`, then this tag must be displayed. If it is set to `false`, it should not be displayed. This value can override the group display value.").optional(), "value": z.string().describe("The value of the tag. This set by the BPP and rendered as-is by the BAP.").optional() }).strict().describe("Describes a tag. This is used to contain extended metadata. This object can be added as a property to any schema to describe extended attributes. For BAPs, tags can be sent during search to optimize and filter search results. BPPs can use tags to index their catalog to allow better search functionality. Tags are sent by the BPP as part of the catalog response in the `on_search` callback. Tags are also meant for display purposes. Upon receiving a tag, BAPs are meant to render them as name-value pairs. This is particularly useful when rendering tabular information about a product or service.")).describe("An array of Tag objects listed under this group. This property can be set by BAPs during search to narrow the `search` and achieve more relevant results. When received during `on_search`, BAPs must render this list under the heading described by the `name` property of this schema.").optional() }).strict().describe("A collection of tag objects with group level attributes. For detailed documentation on the Tags and Tag Groups schema go to https://github.com/beckn/protocol-specifications/discussions/316")).optional(), "url": z.string().url().describe("Profile url of the person").optional() }).strict().describe("Describes a person as any individual").describe("The details of the person present at the stop").optional(), "time": z.object({ "days": z.string().describe("comma separated values representing days of the week").optional(), "duration": z.string().describe("Describes duration as per ISO8601 format").optional(), "label": z.string().optional(), "range": z.object({ "end": z.string().datetime({ offset: true }).optional(), "start": z.string().datetime({ offset: true }).optional() }).optional(), "schedule": z.object({ "frequency": z.string().describe("Describes duration as per ISO8601 format").optional(), "holidays": z.array(z.string().datetime({ offset: true })).optional(), "times": z.array(z.string().datetime({ offset: true })).optional() }).strict().describe("Describes a schedule").optional(), "timestamp": z.string().datetime({ offset: true }).optional() }).strict().describe("Describes time in its various forms. It can be a single point in time; duration; or a structured timetable of operations").describe("Timings applicable at the stop.").optional(), "type": z.enum(["START","END"]).describe("The type of stop. Allowed values of this property can be defined by the network policy.").optional() }).strict().describe("A logical point in space and time during the fulfillment of an order.")).describe("The list of logical stops encountered during the fulfillment of an order.").optional(), "tags": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the TagGroup, can be used to store detailed information.").optional(), "display": z.boolean().describe("Indicates the display properties of the tag group. If display is set to false, then the group will not be displayed. If it is set to true, it should be displayed. However, group-level display properties can be overriden by individual tag-level display property. As this schema is purely for catalog display purposes, it is not recommended to send this value during search.").default(true), "list": z.array(z.object({ "descriptor": z.object({ "additional_desc": z.object({ "content_type": z.enum(["text/plain","text/html","application/json"]).optional(), "url": z.string().optional() }).optional(), "code": z.string().optional(), "images": z.array(z.object({ "height": z.string().describe("Height of the image in pixels").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "url": z.string().url().describe("URL to the image. This can be a data url or an remote url"), "width": z.string().describe("Width of the image in pixels").optional() }).strict().describe("Describes an image")).optional(), "long_desc": z.string().optional(), "media": z.array(z.object({ "dsa": z.string().describe("The signing algorithm used by the sender").optional(), "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "url": z.string().url().describe("The URL of the file").optional() }).strict().describe("This object contains a url to a media file.")).optional(), "name": z.string().optional(), "short_desc": z.string().optional() }).strict().describe("Physical description of something.").describe("Description of the Tag, can be used to store detailed information.").optional(), "display": z.boolean().describe("This value indicates if the tag is intended for display purposes. If set to `true`, then this tag must be displayed. If it is set to `false`, it should not be displayed. This value can override the group display value.").optional(), "value": z.string().describe("The value of the tag. This set by the BPP and rendered as-is by the BAP.").optional() }).strict().describe("Describes a tag. This is used to contain extended metadata. This object can be added as a property to any schema to describe extended attributes. For BAPs, tags can be sent during search to optimize and filter search results. BPPs can use tags to index their catalog to allow better search functionality. Tags are sent by the BPP as part of the catalog response in the `on_search` callback. Tags are also meant for display purposes. Upon receiving a tag, BAPs are meant to render them as name-value pairs. This is particularly useful when rendering tabular information about a product or service.")).describe("An array of Tag objects listed under this group. This property can be set by BAPs during search to narrow the `search` and achieve more relevant results. When received during `on_search`, BAPs must render this list under the heading described by the `name` property of this schema.").optional() }).strict().describe("A collection of tag objects with group level attributes. For detailed documentation on the Tags and Tag Groups schema go to https://github.com/beckn/protocol-specifications/discussions/316")).optional(), "tracking": z.boolean().describe("Indicates whether the fulfillment allows tracking").default(false), "type": z.string().describe("A code that describes the mode of fulfillment. This is typically set when there are multiple ways an order can be fulfilled. For example, a retail order can be fulfilled either via store pickup or a home delivery. Similarly, a medical consultation can be provided either in-person or via tele-consultation. The network policy must publish standard fulfillment type codes for the different modes of fulfillment.").optional(), "vehicle": z.object({ "capacity": z.number().int().optional(), "cargo_volumne": z.string().optional(), "category": z.string().optional(), "code": z.string().optional(), "color": z.string().optional(), "emission_standard": z.string().optional(), "energy_type": z.string().optional(), "make": z.string().optional(), "model": z.string().optional(), "registration": z.string().optional(), "size": z.string().optional(), "variant": z.string().optional(), "wheelchair_access": z.string().optional(), "wheels_count": z.string().optional() }).strict().describe("Describes a vehicle is a device that is designed or used to transport people or cargo over land, water, air, or through space.<br>This has properties like category, capacity, make, model, size,variant,color,energy_type,registration").optional() }).strict().describe("Describes how a an order will be rendered/fulfilled to the end-customer");
