import { z } from "zod";

export default z.object({ "context": z.intersection(z.intersection(z.object({ "domain": z.any().describe("Standard code representing the domain. The standard is usually published as part of the network policy. Furthermore, the network facilitator should also provide a mechanism to provide the supported domains of a network.").describe("Domain code that is relevant to this transaction context").optional(), "location": z.object({ "id": z.string().optional(), "descriptor": z.object({ "name": z.string().optional(), "code": z.string().optional(), "short_desc": z.string().optional(), "long_desc": z.string().optional(), "additional_desc": z.object({ "url": z.string().optional(), "content_type": z.enum(["text/plain","text/html","application/json"]).optional() }).optional(), "media": z.array(z.object({ "mimetype": z.string().describe("indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838").optional(), "url": z.string().url().describe("The URL of the file").optional(), "signature": z.string().describe("The digital signature of the file signed by the sender").optional(), "dsa": z.string().describe("The signing algorithm used by the sender").optional() }).describe("This object contains a url to a media file.")).optional(), "images": z.array(z.object({ "url": z.string().url().describe("URL to the image. This can be a data url or an remote url").optional(), "size_type": z.enum(["xs","sm","md","lg","xl","custom"]).describe("The size of the image. The network policy can define the default dimensions of each type").optional(), "width": z.string().describe("Width of the image in pixels").optional(), "height": z.string().describe("Height of the image in pixels").optional() }).describe("Describes an image")).optional() }).describe("Physical description of something.").optional(), "map_url": z.string().url().describe("The url to the map of the location. This can be a globally recognized map url or the one specified by the network policy.").optional(), "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?),\\s*[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?)$")).describe("Describes a GPS coordinate").describe("The GPS co-ordinates of this location.").optional(), "address": z.string().describe("Describes a postal address.").describe("The address of this location.").optional(), "city": z.object({ "name": z.string().describe("Name of the city").optional(), "code": z.string().describe("City code").optional() }).describe("Describes a city").describe("The city this location is, or is located within").optional(), "district": z.string().describe("The state this location is, or is located within").optional(), "state": z.object({ "name": z.string().describe("Name of the state").optional(), "code": z.string().describe("State code as per country or international standards").optional() }).describe("A bounded geopolitical region of governance inside a country.").describe("The state this location is, or is located within").optional(), "country": z.object({ "name": z.string().describe("Name of the country").optional(), "code": z.string().describe("Country code as per ISO 3166-1 and ISO 3166-2 format").optional() }).describe("Describes a country").describe("The country this location is, or is located within").optional(), "area_code": z.string().optional(), "circle": z.object({ "gps": z.string().regex(new RegExp("^[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?),\\s*[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?)$")).describe("Describes a GPS coordinate").optional(), "radius": z.object({ "type": z.enum(["CONSTANT","VARIABLE"]).optional(), "value": z.string().regex(new RegExp("[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a numerical value in decimal form").optional(), "estimated_value": z.string().regex(new RegExp("[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a numerical value in decimal form").optional(), "computed_value": z.string().regex(new RegExp("[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a numerical value in decimal form").optional(), "range": z.object({ "min": z.string().regex(new RegExp("[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a numerical value in decimal form").optional(), "max": z.string().regex(new RegExp("[+-]?([0-9]*[.])?[0-9]+")).describe("Describes a numerical value in decimal form").optional() }).optional(), "unit": z.string().optional() }).describe("Describes a scalar").optional() }).describe("Describes a circular region of a specified radius centered at a specified GPS coordinate.").optional(), "polygon": z.string().describe("The boundary polygon of this location").optional(), "3dspace": z.string().describe("The three dimensional region describing this location").optional(), "rating": z.string().describe("Rating value given to the object. This can be a single value or can also contain an inequality operator like gt, gte, lt, lte. This can also contain an inequality expression containing logical operators like && and ||.").describe("The rating of this location").optional() }).describe("The physical location of something").describe("The location where the transaction is intended to be fulfilled.").optional(), "action": z.string().describe("The Beckn protocol method being called by the sender and executed at the receiver.").optional(), "version": z.string().describe("Version of transaction protocol being used by the sender.").optional(), "bap_id": z.string().describe("A globally unique identifier of the platform, Typically it is the fully qualified domain name (FQDN) of the platform.").describe("Subscriber ID of the BAP").optional(), "bap_uri": z.string().url().describe("The callback URL of the Subscriber. This should necessarily contain the same domain name as set in `subscriber_id``.").describe("Subscriber URL of the BAP for accepting callbacks from BPPs.").optional(), "bpp_id": z.string().describe("A globally unique identifier of the platform, Typically it is the fully qualified domain name (FQDN) of the platform.").describe("Subscriber ID of the BPP").optional(), "bpp_uri": z.string().url().describe("The callback URL of the Subscriber. This should necessarily contain the same domain name as set in `subscriber_id``.").describe("Subscriber URL of the BPP for accepting calls from BAPs.").optional(), "transaction_id": z.string().uuid().describe("This is a unique value which persists across all API calls from `search` through `confirm`. This is done to indicate an active user session across multiple requests. The BPPs can use this value to push personalized recommendations, and dynamic offerings related to an ongoing transaction despite being unaware of the user active on the BAP.").optional(), "message_id": z.string().uuid().describe("This is a unique value which persists during a request / callback cycle. Since beckn protocol APIs are asynchronous, BAPs need a common value to match an incoming callback from a BPP to an earlier call. This value can also be used to ignore duplicate messages coming from the BPP. It is recommended to generate a fresh message_id for every new interaction. When sending unsolicited callbacks, BPPs must generate a new message_id.").optional(), "timestamp": z.string().datetime({ offset: true }).describe("Time of request generation in RFC3339 format").optional(), "key": z.string().describe("The encryption public key of the sender").optional(), "ttl": z.string().describe("The duration in ISO8601 format after timestamp for which this message holds valid").optional() }).describe("Every API call in beckn protocol has a context. It provides a high-level overview to the receiver about the nature of the intended transaction. Typically, it is the BAP that sets the transaction context based on the consumer's location and action on their UI. But sometimes, during unsolicited callbacks, the BPP also sets the transaction context but it is usually the same as the context of a previous full-cycle, request-callback interaction between the BAP and the BPP. The context object contains four types of fields. <ol><li>Demographic information about the transaction using fields like `domain`, `country`, and `region`.</li><li>Addressing details like the sending and receiving platform's ID and API URL.</li><li>Interoperability information like the protocol version that implemented by the sender and,</li><li>Transaction details like the method being called at the receiver's endpoint, the transaction_id that represents an end-to-end user session at the BAP, a message ID to pair requests with callbacks, a timestamp to capture sending times, a ttl to specifiy the validity of the request, and a key to encrypt information if necessary.</li></ol> This object must be passed in every interaction between a BAP and a BPP. In HTTP/S implementations, it is not necessary to send the context during the synchronous response. However, in asynchronous protocols, the context must be sent during all interactions,"), z.object({ "schema_context": z.array(z.string().url()).describe("Optional JSON-LD context URLs indicating item types to search across").optional() }).describe("Beckn Context extended for Discovery.")), z.object({ "action": z.literal("on_discover").optional() })), "message": z.object({ "catalogs": z.array(z.object({ "@context": z.literal("https://raw.githubusercontent.com/beckn/protocol-specifications-new/refs/heads/draft/schema/core/v2/context.jsonld").describe("JSON-LD context URI for the core Catalog schema"), "@type": z.string().describe("Type of the catalog"), "beckn:id": z.string().describe("Unique identifier for the catalog"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:providerId": z.string().describe("Reference to the provider that owns this catalog").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:items": z.array(z.object({ "@context": z.literal("https://raw.githubusercontent.com/beckn/protocol-specifications-new/refs/heads/draft/schema/core/v2/context.jsonld").describe("JSON-LD context URI for the core Item schema"), "@type": z.literal("beckn:Item").describe("Type of the core item"), "beckn:id": z.string().describe("Unique identifier for the item"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:category": z.object({ "@type": z.literal("schema:CategoryCode").describe("Type of the category code"), "schema:codeValue": z.string().describe("Category code value"), "schema:name": z.string().describe("Category name").optional(), "schema:description": z.string().describe("Category description").optional() }).optional(), "beckn:availableAt": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Physical locations where the item is available").optional(), "beckn:availabilityWindow": z.array(z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity")).describe("Time periods when the item is available").optional(), "beckn:rateable": z.boolean().describe("Whether the item can be rated by customers").optional(), "beckn:rating": z.object({ "@type": z.literal("beckn:Rating").describe("Type of the rating"), "beckn:ratingValue": z.number().gte(0).lte(5).describe("Rating value (0-5)").optional(), "beckn:ratingCount": z.number().int().gte(0).describe("Number of ratings").optional() }).optional(), "beckn:isActive": z.boolean().describe("Whether the item is active").default(true), "beckn:networkId": z.array(z.string()).describe("Array of network identifiers for the BAP (Beckn App Provider) that offers this item").optional(), "beckn:provider": z.object({ "beckn:id": z.string().describe("Unique identifier for the provider"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:locations": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Physical locations where the provider operates").optional(), "beckn:rateable": z.boolean().describe("Whether the provider can be rated by customers").optional(), "beckn:rating": z.object({ "@type": z.literal("beckn:Rating").describe("Type of the rating"), "beckn:ratingValue": z.number().gte(0).lte(5).describe("Rating value (0-5)").optional(), "beckn:ratingCount": z.number().int().gte(0).describe("Number of ratings").optional() }).optional(), "beckn:providerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict(), "beckn:itemAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n") }).strict()).describe("Array of beckn core Item entities in this catalog, returned directly without ItemResult wrapper for improved performance and simplified response structure\n"), "beckn:offers": z.array(z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Offer"), "beckn:id": z.string().describe("Unique id for this offer"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:provider": z.string().describe("Seller / provider of this offer"), "beckn:items": z.array(z.string().describe("Unique identifier for the item")).min(1).describe("Base item(s) the offer applies to (single or bundle)"), "beckn:addOns": z.array(z.string().describe("Unique id for this offer")).describe("Optional extra Offers that can be attached (e.g., warranty, gift wrap)").optional(), "beckn:addOnItems": z.array(z.string().describe("Unique identifier for the item")).describe("Optional extras modeled as items (e.g., toppings, accessories)").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:price": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Price snapshot; detailed models can live in offerAttributes").optional(), "beckn:eligibleRegion": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Regions where the offer is eligible").optional(), "beckn:acceptedPaymentMethod": z.array(z.enum(["UPI","CreditCard","DebitCard","Wallet","BankTransfer","Cash","ApplePay"])).describe("Payment methods accepted for this offer").optional(), "beckn:itemCondition": z.enum(["NEW","USED","REFURBISHED","DAMAGED"]).describe("Condition of the item being offered").optional(), "beckn:offerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict()).optional() }).strict()).describe("Array of catalogs containing items").optional() }) });
