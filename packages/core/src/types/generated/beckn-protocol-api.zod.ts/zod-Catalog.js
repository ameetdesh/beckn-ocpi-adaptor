import { z } from "zod";

export default z.object({ "@context": z.literal("https://raw.githubusercontent.com/beckn/protocol-specifications-new/refs/heads/draft/schema/core/v2/context.jsonld").describe("JSON-LD context URI for the core Catalog schema"), "@type": z.string().describe("Type of the catalog"), "beckn:id": z.string().describe("Unique identifier for the catalog"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:providerId": z.string().describe("Reference to the provider that owns this catalog").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:items": z.array(z.object({ "@context": z.literal("https://raw.githubusercontent.com/beckn/protocol-specifications-new/refs/heads/draft/schema/core/v2/context.jsonld").describe("JSON-LD context URI for the core Item schema"), "@type": z.literal("beckn:Item").describe("Type of the core item"), "beckn:id": z.string().describe("Unique identifier for the item"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:category": z.object({ "@type": z.literal("schema:CategoryCode").describe("Type of the category code"), "schema:codeValue": z.string().describe("Category code value"), "schema:name": z.string().describe("Category name").optional(), "schema:description": z.string().describe("Category description").optional() }).optional(), "beckn:availableAt": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Physical locations where the item is available").optional(), "beckn:availabilityWindow": z.array(z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity")).describe("Time periods when the item is available").optional(), "beckn:rateable": z.boolean().describe("Whether the item can be rated by customers").optional(), "beckn:rating": z.object({ "@type": z.literal("beckn:Rating").describe("Type of the rating"), "beckn:ratingValue": z.number().gte(0).lte(5).describe("Rating value (0-5)").optional(), "beckn:ratingCount": z.number().int().gte(0).describe("Number of ratings").optional() }).optional(), "beckn:isActive": z.boolean().describe("Whether the item is active").default(true), "beckn:networkId": z.array(z.string()).describe("Array of network identifiers for the BAP (Beckn App Provider) that offers this item").optional(), "beckn:provider": z.object({ "beckn:id": z.string().describe("Unique identifier for the provider"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:locations": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Physical locations where the provider operates").optional(), "beckn:rateable": z.boolean().describe("Whether the provider can be rated by customers").optional(), "beckn:rating": z.object({ "@type": z.literal("beckn:Rating").describe("Type of the rating"), "beckn:ratingValue": z.number().gte(0).lte(5).describe("Rating value (0-5)").optional(), "beckn:ratingCount": z.number().int().gte(0).describe("Number of ratings").optional() }).optional(), "beckn:providerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict(), "beckn:itemAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n") }).strict()).describe("Array of beckn core Item entities in this catalog, returned directly without ItemResult wrapper for improved performance and simplified response structure\n"), "beckn:offers": z.array(z.object({ "@context": z.string().url(), "@type": z.literal("beckn:Offer"), "beckn:id": z.string().describe("Unique id for this offer"), "beckn:descriptor": z.object({ "@type": z.literal("beckn:Descriptor").describe("Type of the descriptor"), "schema:name": z.string().describe("Name of the item").optional(), "beckn:shortDesc": z.string().describe("Short description of the item").optional(), "beckn:longDesc": z.string().describe("Detailed description of the item").optional(), "schema:image": z.array(z.string().url()).optional() }), "beckn:provider": z.string().describe("Seller / provider of this offer"), "beckn:items": z.array(z.string().describe("Unique identifier for the item")).min(1).describe("Base item(s) the offer applies to (single or bundle)"), "beckn:addOns": z.array(z.string().describe("Unique id for this offer")).describe("Optional extra Offers that can be attached (e.g., warranty, gift wrap)").optional(), "beckn:addOnItems": z.array(z.string().describe("Unique identifier for the item")).describe("Optional extras modeled as items (e.g., toppings, accessories)").optional(), "beckn:validity": z.object({ "@type": z.string().describe("JSON-LD type for a date-time period"), "schema:startDate": z.string().datetime({ offset: true }).describe("Start instant (inclusive)").optional(), "schema:endDate": z.string().datetime({ offset: true }).describe("End instant (exclusive or inclusive per domain semantics)").optional(), "schema:startTime": z.string().time().describe("Start time of the time period").optional(), "schema:endTime": z.string().time().describe("End time of the time period").optional() }).and(z.union([z.any(), z.any(), z.any()])).describe("Time window with date-time precision for availability/validity").optional(), "beckn:price": z.object({ "currency": z.string().describe("ISO 4217 code").optional(), "value": z.number().describe("Total value for this price specification").optional(), "applicableQuantity": z.object({ "unitText": z.string().describe("Unit for the quoted price (e.g., kWh, minute, hour, month)").optional(), "unitCode": z.string().describe("Unit code for the quoted price (e.g., KWH, MIN, H, MON)").optional(), "unitQuantity": z.number().describe("Quantity of the unit").optional(), "minQuantity": z.number().describe("Minimum quantity for this price").optional(), "maxQuantity": z.number().describe("Maximum quantity for this price").optional() }).optional(), "x-jsonld": z.any().optional(), "components": z.array(z.object({ "type": z.enum(["UNIT","TAX","DELIVERY","DISCOUNT","FEE","SURCHARGE"]).optional(), "value": z.number().optional(), "currency": z.string().optional(), "description": z.string().optional() })).describe("Optional components (tax, shipping, discount, fee, surcharge)").optional() }).catchall(z.any()).describe("Price snapshot; detailed models can live in offerAttributes").optional(), "beckn:eligibleRegion": z.array(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n")).describe("Regions where the offer is eligible").optional(), "beckn:acceptedPaymentMethod": z.array(z.enum(["UPI","CreditCard","DebitCard","Wallet","BankTransfer","Cash","ApplePay"])).describe("Payment methods accepted for this offer").optional(), "beckn:itemCondition": z.enum(["NEW","USED","REFURBISHED","DAMAGED"]).describe("Condition of the item being offered").optional(), "beckn:offerAttributes": z.object({ "@context": z.string().url().describe("JSON-LD context URI for the specific domain schema (e.g., ElectronicItem)"), "@type": z.string().describe("JSON-LD type within the domain schema") }).catchall(z.any()).describe("JSON-LD aware bag for domain-specific attributes of an Item. MUST include @context (URI) and @type (compact or full IRI). Any additional properties are allowed and interpreted per the provided JSON-LD context.\n").optional() }).strict()).optional() }).strict();
