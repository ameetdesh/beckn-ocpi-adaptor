import { z } from "zod";

export default z.object({ "connectorType": z.enum(["CCS2","Type2","CHAdeMO","GB_T"]).describe("Physical connector type supported by this EVSE."), "maxPowerKW": z.number().gte(1).lte(500).describe("Maximum output power of the connector (kW)."), "minPowerKW": z.number().gte(0).lte(500).describe("Minimum controllable power if throttling supported (kW).").optional(), "socketCount": z.number().int().gte(1).describe("Number of simultaneously usable outlets for this connector type."), "reservationSupported": z.boolean().describe("Whether advance reservations are supported.").default(true), "serviceLocation": z.intersection(z.object({ "@type": z.literal("beckn:Location").optional(), "geo": z.object({ "type": z.enum(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"]), "coordinates": z.array(z.any()).describe("Coordinates per RFC 7946 for all types **except** GeometryCollection. Order is **[lon, lat, (alt)]**. For Polygons, this is an array of linear rings; each ring is an array of positions.\n").optional(), "geometries": z.array(z.any()).describe("Member geometries when `type` is **GeometryCollection**.\n").optional(), "bbox": z.array(z.any()).min(4).max(4).describe("Optional bounding box `[west, south, east, north]` in degrees.").optional() }).catchall(z.any()).describe("**GeoJSON geometry** per RFC 7946. Coordinates are in **EPSG:4326 (WGS-84)** and MUST follow **[longitude, latitude, (altitude?)]** order.\nSupported types: - Point, LineString, Polygon - MultiPoint, MultiLineString, MultiPolygon - GeometryCollection (uses `geometries` instead of `coordinates`)\nNotes: - For rectangles, use a Polygon with a single linear ring where the first\n  and last positions are identical.\n- Circles are **not native** to GeoJSON. For circular searches, use\n  `SpatialConstraint` with `op: s_dwithin` and a Point + `distanceMeters`,\n  or approximate the circle as a Polygon.\n- Optional `bbox` is `[west, south, east, north]` in degrees.\n"), "address": z.any().superRefine((x, ctx) => {
    const schemas = [z.string(), z.object({ "streetAddress": z.string().describe("Street address (building name/number and street).").optional(), "extendedAddress": z.string().describe("Address extension (apt/suite/floor, C/O).").optional(), "addressLocality": z.string().describe("City/locality.").optional(), "addressRegion": z.string().describe("State/region/province.").optional(), "postalCode": z.string().describe("Postal/ZIP code.").optional(), "addressCountry": z.string().describe("Country name or ISO-3166-1 alpha-2 code.").optional() }).strict().describe("**Postal address** aligned with schema.org `PostalAddress`. Use for human-readable addresses. Geometry lives in `Location.geo` as GeoJSON.\n")];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }).describe("Optional human-readable address for the same place/area.").optional() }).strict().describe("A **place** represented by **GeoJSON geometry** (Point/Polygon/Multi*) and optional human-readable `address`. This unifies all Beckn location fields into a single, widely-adopted representation (GeoJSON).\n"), z.record(z.any()).describe("Location of the charging site (reuses Beckn Location).")).optional(), "amenityFeature": z.array(z.string()).describe("Nearby amenities (e.g., Restaurant, Restroom, Wi-Fi).").optional(), "ocppId": z.string().describe("Site/CSMS identifier in OCPP backend.").optional(), "evseId": z.string().describe("EVSE identifier (e.g., OCPI/Hubject style).").optional(), "roamingNetwork": z.string().describe("Roaming network name if applicable.").optional(), "parkingType": z.enum(["OnStreet","OffStreet","Basement","Mall","FuelStation","Office","Hotel"]).describe("Parking context of the station.").optional(), "connectorId": z.string().describe("Provider-specific connector/socket id.").optional(), "powerType": z.enum(["AC_SINGLE_PHASE","AC_3_PHASE","DC"]).describe("Electrical system type at the connector.").optional(), "connectorFormat": z.enum(["SOCKET","CABLE"]).describe("Whether the gun is tethered (CABLE) or socketed (SOCKET).").optional(), "chargingSpeed": z.enum(["SLOW","NORMAL","FAST","ULTRAFAST"]).describe("Marketing band for comprehension.").optional(), "stationStatus": z.enum(["Available","Occupied","OutOfService"]).describe("Near-real-time availability state.").optional() }).strict();
